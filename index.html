<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Rob a Cat 2D</title>
<style>
body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(to bottom, #1a2980, #26d0ce);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

#gameContainer {
    position: relative;
    width: 800px;
    height: 600px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    overflow: hidden;
}

#gameCanvas {
    background: #87CEEB;
    display: block;
}

#ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

#score {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    background: rgba(0, 0, 0, 0.3);
    padding: 10px 15px;
    border-radius: 10px;
}

#playerName {
    position: absolute;
    top: 20px;
    right: 20px;
    color: white;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    background: rgba(0, 0, 0, 0.3);
    padding: 10px 15px;
    border-radius: 10px;
}

#leaderboard {
    position: absolute;
    top: 70px;
    right: 20px;
    color: white;
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 10px;
    min-width: 150px;
    max-height: 300px;
    overflow-y: auto;
}

.leaderboard-entry {
    margin: 8px 0;
    padding: 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 14px;
}

.leaderboard-entry:last-child {
    border-bottom: none;
}

#instructions {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    text-align: center;
    z-index: 10;
    background: rgba(0, 0, 0, 0.8);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
    max-width: 500px;
    width: 80%;
}

#instructions h2 {
    margin-top: 0;
    color: #4fc3f7;
    text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
}

#instructions p {
    margin: 10px 0;
    font-size: 16px;
}

#startButton {
    background: linear-gradient(to bottom, #2196F3, #0d47a1);
    color: white;
    border: none;
    padding: 12px 25px;
    font-size: 18px;
    border-radius: 30px;
    cursor: pointer;
    margin-top: 20px;
    transition: all 0.3s;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    pointer-events: auto;
}

#startButton:hover {
    background: linear-gradient(to bottom, #42A5F5, #1565C0);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

#controls {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: white;
    background: rgba(0, 0, 0, 0.3);
    padding: 10px 15px;
    border-radius: 10px;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

#gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    text-align: center;
    z-index: 20;
    background: rgba(0, 0, 0, 0.8);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
    display: none;
}

#gameOver h2 {
    margin-top: 0;
    color: #ff5252;
}

#restartButton {
    background: linear-gradient(to bottom, #ff5252, #b71c1c);
    color: white;
    border: none;
    padding: 12px 25px;
    font-size: 18px;
    border-radius: 30px;
    cursor: pointer;
    margin-top: 20px;
    transition: all 0.3s;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

#restartButton:hover {
    background: linear-gradient(to bottom, #ff7979, #d32f2f);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

/* Scrollbar styling */
#leaderboard::-webkit-scrollbar {
    width: 8px;
}

#leaderboard::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}

#leaderboard::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
}

#leaderboard::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
}

/* Power-up indicators */
#powerUps {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
}

.power-up-indicator {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 0 0 3px black;
    opacity: 0.7;
}

.power-up-indicator.active {
    opacity: 1;
    box-shadow: 0 0 10px white;
}
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="playerName">Player: <span id="playerNameValue">Unknown</span></div>
        <div id="powerUps"></div>
        <div id="leaderboard">
            <div><b>Leaderboard:</b></div>
        </div>
        <div id="controls">
            <div>WASD - Move | ESC - Restart</div>
        </div>
    </div>
    
    <div id="instructions">
        <h2>Rob a Cat 2D</h2>
        <p>Collect as many cats as you can! Avoid other players.</p>
        <p>Use WASD to move around the 2D world</p>
        <p>Collect power-ups for special abilities!</p>
        <button id="startButton">Start Game</button>
    </div>
    
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Your final score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
// Game variables
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const playerNameElement = document.getElementById('playerNameValue');
const leaderboardElement = document.getElementById('leaderboard');
const instructionsElement = document.getElementById('instructions');
const gameOverElement = document.getElementById('gameOver');
const finalScoreElement = document.getElementById('finalScore');
const startButton = document.getElementById('startButton');
const restartButton = document.getElementById('restartButton');
const powerUpsElement = document.getElementById('powerUps');

// Game state
let gameRunning = false;
let myScore = 0;
let playerName = "Player";
let players = {};
let cats = [];
let powerUps = [];
let enemies = [];
let myId = null;
let keys = {};
let socket;
let particles = [];
let powerUpTimers = {
    speed: 0,
    invincible: 0
};

// Player properties
const playerSize = 30;
let playerX = 400;
let playerY = 300;
let playerSpeed = 4;
let isInvincible = false;

// Cat properties
const catSize = 20;

// Enemy properties
const enemySize = 25;
const enemySpeed = 1.5;

// Power-up properties
const powerUpSize = 15;

// Connect to the server
socket = io();

// Initialize game
function initGame() {
    gameRunning = true;
    myScore = 0;
    scoreElement.textContent = 'Score: 0';
    playerX = 400;
    playerY = 300;
    isInvincible = false;
    powerUpTimers = { speed: 0, invincible: 0 };
    particles = [];
    
    // Hide UI elements
    instructionsElement.style.display = 'none';
    gameOverElement.style.display = 'none';
    
    // Start game loop
    requestAnimationFrame(gameLoop);
}

// Draw game elements
function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background grid
    drawGrid();
    
    // Draw particles
    drawParticles();
    
    // Draw power-ups
    powerUps.forEach(powerUp => {
        drawPowerUp(powerUp.x, powerUp.y, powerUp.type);
    });
    
    // Draw enemies
    enemies.forEach(enemy => {
        drawEnemy(enemy.x, enemy.y);
    });
    
    // Draw cats
    cats.forEach(cat => {
        drawCat(cat.x, cat.y);
    });
    
    // Draw players
    for (const id in players) {
        const player = players[id];
        drawPlayer(player.x, player.y, id === myId, player.name, id === myId ? isInvincible : false);
    }
    
    // Draw player name tag
    if (myId && players[myId]) {
        drawPlayerTag(players[myId].x, players[myId].y);
    }
    
    // Draw power-up indicators
    drawPowerUpIndicators();
}

// Draw background grid
function drawGrid() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

// Draw a cat
function drawCat(x, y) {
    // Cat body
    ctx.fillStyle = '#FF9900';
    ctx.beginPath();
    ctx.arc(x, y, catSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Cat ears
    ctx.fillStyle = '#FF9900';
    ctx.beginPath();
    ctx.moveTo(x - catSize/3, y - catSize/3);
    ctx.lineTo(x, y - catSize/2);
    ctx.lineTo(x + catSize/3, y - catSize/3);
    ctx.closePath();
    ctx.fill();
    
    // Cat eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - catSize/5, y - catSize/6, catSize/8, 0, Math.PI * 2);
    ctx.arc(x + catSize/5, y - catSize/6, catSize/8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - catSize/5, y - catSize/6, catSize/12, 0, Math.PI * 2);
    ctx.arc(x + catSize/5, y - catSize/6, catSize/12, 0, Math.PI * 2);
    ctx.fill();
    
    // Cat nose
    ctx.fillStyle = '#FF6600';
    ctx.beginPath();
    ctx.arc(x, y + catSize/10, catSize/10, 0, Math.PI * 2);
    ctx.fill();
    
    // Cat tail
    ctx.strokeStyle = '#FF9900';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x - catSize/2, y);
    ctx.lineTo(x - catSize, y + catSize/2);
    ctx.stroke();
}

// Draw a player
function drawPlayer(x, y, isMe, name, isInvincible) {
    // Player body
    if (isMe) {
        ctx.fillStyle = isInvincible ? '#00FFFF' : '#00FFFF';
    } else {
        ctx.fillStyle = '#FFFFFF';
    }
    
    ctx.beginPath();
    ctx.arc(x, y, playerSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Player details
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(x, y, playerSize/3, 0, Math.PI * 2);
    ctx.fill();
    
    // Player name tag
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(name || 'Player', x, y - playerSize/2 - 5);
    
    // Draw invincibility effect
    if (isInvincible) {
        ctx.strokeStyle = '#00FFFF';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, playerSize/2 + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// Draw player name tag above player
function drawPlayerTag(x, y) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(x - 30, y - 45, 60, 25);
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(playerName, x, y - 30);
}

// Draw an enemy
function drawEnemy(x, y) {
    // Enemy body
    ctx.fillStyle = '#FF5252';
    ctx.beginPath();
    ctx.arc(x, y, enemySize/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Enemy eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - enemySize/5, y - enemySize/6, enemySize/8, 0, Math.PI * 2);
    ctx.arc(x + enemySize/5, y - enemySize/6, enemySize/8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - enemySize/5, y - enemySize/6, enemySize/12, 0, Math.PI * 2);
    ctx.arc(x + enemySize/5, y - enemySize/6, enemySize/12, 0, Math.PI * 2);
    ctx.fill();
    
    // Enemy mouth
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y + enemySize/10, enemySize/5, 0, Math.PI);
    ctx.stroke();
}

// Draw a power-up
function drawPowerUp(x, y, type) {
    let color, symbol;
    
    switch(type) {
        case 'speed':
            color = '#4CAF50';
            symbol = 'S';
            break;
        case 'invincible':
            color = '#9C27B0';
            symbol = 'I';
            break;
        default:
            color = '#FF9800';
            symbol = '?';
    }
    
    // Power-up circle
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, powerUpSize/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Power-up symbol
    ctx.fillStyle = 'white';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(symbol, x, y + 5);
}

// Draw particles
function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// Draw power-up indicators
function drawPowerUpIndicators() {
    powerUpsElement.innerHTML = '';
    
    const indicators = [
        { type: 'speed', label: 'S', active: powerUpTimers.speed > 0 },
        { type: 'invincible', label: 'I', active: powerUpTimers.invincible > 0 }
    ];
    
    indicators.forEach(indicator => {
        const div = document.createElement('div');
        div.className = `power-up-indicator ${indicator.active ? 'active' : ''}`;
        div.textContent = indicator.label;
        div.title = indicator.type.charAt(0).toUpperCase() + indicator.type.slice(1);
        powerUpsElement.appendChild(div);
    });
}

// Create particles
function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            size: Math.random() * 3 + 1,
            color: color,
            alpha: 1,
            velocity: {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 4
            }
        });
    }
}

// Update particles
function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.velocity.x;
        p.y += p.velocity.y;
        p.alpha -= 0.02;
        
        if (p.alpha <= 0) {
            particles.splice(i, 1);
        }
    }
}

// Update game state
function update() {
    if (!gameRunning) return;
    
    // Update power-up timers
    if (powerUpTimers.speed > 0) {
        powerUpTimers.speed--;
    }
    
    if (powerUpTimers.invincible > 0) {
        powerUpTimers.invincible--;
        if (powerUpTimers.invincible === 0) {
            isInvincible = false;
        }
    }
    
    // Move player based on keys pressed
    let speed = playerSpeed;
    if (powerUpTimers.speed > 0) {
        speed *= 1.5;
    }
    
    if (keys['w'] || keys['ArrowUp']) {
        playerY = Math.max(playerSize/2, playerY - speed);
    }
    if (keys['s'] || keys['ArrowDown']) {
        playerY = Math.min(canvas.height - playerSize/2, playerY + speed);
    }
    if (keys['a'] || keys['ArrowLeft']) {
        playerX = Math.max(playerSize/2, playerX - speed);
    }
    if (keys['d'] || keys['ArrowRight']) {
        playerX = Math.min(canvas.width - playerSize/2, playerX + speed);
    }
    
    // Send movement to server
    if (myId) {
        socket.emit('move', { x: playerX, z: playerY });
    }
    
    // Update particles
    updateParticles();
}

// Game loop
function gameLoop() {
    if (!gameRunning) return;
    
    update();
    draw();
    
    requestAnimationFrame(gameLoop);
}

// Socket event handlers
socket.on('init', (data) => {
    players = data.players;
    cats = data.cats;
    powerUps = data.powerUps || [];
    enemies = data.enemies || [];
    myId = data.id;
    playerName = data.players[myId].name || "Player";
    playerNameElement.textContent = playerName;
    initGame();
});

socket.on('newPlayer', (data) => {
    players[data.id] = data.player;
});

socket.on('update', (data) => {
    players = data.players;
    cats = data.cats;
    powerUps = data.powerUps || [];
    enemies = data.enemies || [];
    updateLeaderboard();
});

socket.on('score', (score) => {
    myScore = score;
    scoreElement.textContent = 'Score: ' + myScore;
});

socket.on('powerUpCollected', (type) => {
    // Apply power-up effect
    switch(type) {
        case 'speed':
            powerUpTimers.speed = 300; // 5 seconds at 60fps
            break;
        case 'invincible':
            powerUpTimers.invincible = 300;
            isInvincible = true;
            break;
    }
    
    // Create visual effect
    createParticles(playerX, playerY, '#4CAF50', 20);
});

socket.on('enemyCollision', () => {
    if (isInvincible) return;
    
    // Game over
    gameOverElement.style.display = 'block';
    finalScoreElement.textContent = myScore;
    gameRunning = false;
});

// Update leaderboard display
function updateLeaderboard() {
    leaderboardElement.innerHTML = '<div><b>Leaderboard:</b></div>';
    
    // Create array of players for sorting
    const playerList = Object.entries(players)
        .map(([id, player]) => ({ id, ...player }))
        .sort((a, b) => b.score - a.score);
    
    // Display top 10 players
    playerList.slice(0, 10).forEach(player => {
        const entry = document.createElement('div');
        entry.className = 'leaderboard-entry';
        entry.textContent = `${player.name || `Player ${player.id.substring(0, 5)}`}: ${player.score}`;
        leaderboardElement.appendChild(entry);
    });
}

// Event listeners
startButton.addEventListener('click', () => {
    // Get player name
    playerName = prompt('Enter your name:', 'Player') || 'Player';
    playerNameElement.textContent = playerName;
    
    // Connect to server and initialize game
    socket.emit('join', { name: playerName });
});

restartButton.addEventListener('click', () => {
    // Reset game state
    myScore = 0;
    scoreElement.textContent = 'Score: 0';
    playerX = 400;
    playerY = 300;
    isInvincible = false;
    powerUpTimers = { speed: 0, invincible: 0 };
    particles = [];
    
    // Reconnect to server
    socket.emit('join', { name: playerName });
});

document.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    
    // Escape key to restart
    if (e.key === 'Escape' && gameRunning) {
        gameOverElement.style.display = 'block';
        finalScoreElement.textContent = myScore;
        gameRunning = false;
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

// Initial draw
draw();
</script>
</body>
</html>
