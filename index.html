<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rob a Cat 3D</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
#score { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; font-size:20px; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
const socket = io();

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
const ambient = new THREE.AmbientLight(0x777777);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(10, 20, 10);
scene.add(dir);

// Ground
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Objects
const players = {};
let cats = [];
let myId;
let score = 0;

// Mesh builders
function makePlayer(color=0x00ffff) {
  const geo = new THREE.BoxGeometry(1,2,1);
  const mat = new THREE.MeshPhongMaterial({ color });
  const m = new THREE.Mesh(geo, mat);
  m.position.y = 1;
  return m;
}
function makeCat() {
  const geo = new THREE.SphereGeometry(0.6, 16, 16);
  const mat = new THREE.MeshPhongMaterial({ color: 0xff9900 });
  const m = new THREE.Mesh(geo, mat);
  m.position.y = 0.6;
  return m;
}

// Socket events
socket.on('init', data => {
  myId = data.id;
  for (const id in data.players) {
    const mesh = makePlayer(id === myId ? 0x00ffff : 0xffffff);
    mesh.position.set(data.players[id].x, 1, data.players[id].z);
    scene.add(mesh);
    players[id] = { mesh, score: data.players[id].score };
  }
  cats = [];
  data.cats.forEach(cat => {
    const m = makeCat();
    m.position.set(cat.x, 0.6, cat.z);
    scene.add(m);
    cats.push({ id: cat.id, mesh: m });
  });
});

socket.on('newPlayer', data => {
  const mesh = makePlayer(0xffffff);
  mesh.position.set(data.player.x, 1, data.player.z);
  scene.add(mesh);
  players[data.id] = { mesh, score: data.player.score };
});

socket.on('update', data => {
  // Update players
  for (const id in players) {
    if (!data.players[id]) {
      scene.remove(players[id].mesh);
      delete players[id];
      continue;
    }
  }
  for (const id in data.players) {
    const p = data.players[id];
    if (!players[id]) {
      const mesh = makePlayer(0xffffff);
      scene.add(mesh);
      players[id] = { mesh, score: p.score };
    }
    players[id].mesh.position.x = p.x;
    players[id].mesh.position.z = p.z;
  }
  // Update cats
  cats.forEach(c => scene.remove(c.mesh));
  cats = [];
  data.cats.forEach(c => {
    const m = makeCat();
    m.position.set(c.x, 0.6, c.z);
    scene.add(m);
    cats.push({ id: c.id, mesh: m });
  });
});

socket.on('score', s => {
  score = s;
  document.getElementById('score').innerText = 'Score: ' + score;
});

// Controls
const keys = {};
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function animate() {
  requestAnimationFrame(animate);

  const me = players[myId];
  if (me) {
    const pos = me.mesh.position;
    const speed = 0.25;
    if (keys['w'] || keys['arrowup']) pos.z -= speed;
    if (keys['s'] || keys['arrowdown']) pos.z += speed;
    if (keys['a'] || keys['arrowleft']) pos.x -= speed;
    if (keys['d'] || keys['arrowright']) pos.x += speed;
    socket.emit('move', { x: pos.x, z: pos.z });

    // Camera follow
    camera.position.x = pos.x;
    camera.position.z = pos.z + 8;
    camera.position.y = 6;
    camera.lookAt(pos.x, 1, pos.z);
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
